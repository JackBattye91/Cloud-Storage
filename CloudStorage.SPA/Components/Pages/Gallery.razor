@page "/gallery"
@rendermode InteractiveServer
@inject IHttpClientFactory clientFactory;
@inject IConfiguration configuration;
@inject ISessionStorageService sessionStorage;
@inject ProtectedLocalStorage protectedStorage;
@inject ISnackbar snackbar;
@inject NavigationManager navManager;
<PageTitle>Gallery</PageTitle>

<MudContainer>
    <MudGrid>
        <MudItem>
            <MudText Typo="Typo.h3">Gallery</MudText>
        </MudItem>
        <MudSpacer/>
        <MudItem Style="margin: auto 0;">
            <MudGrid>
                <MudItem>
                    <MudFileUpload T="IBrowserFile" FilesChanged="UploadFiles" Class="m-0">
                        <ButtonTemplate>
                            <MudButton HtmlTag="label"
                                       Variant="Variant.Filled"
                                       Color="Color.Primary"
                                       StartIcon="@Icons.Material.Filled.CloudUpload"
                                       for="@context.Id">
                                Upload Files
                            </MudButton>
                        </ButtonTemplate>
                    </MudFileUpload>
                </MudItem>

                <MudItem>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Folder">
                        Create Folder
                    </MudButton>
                </MudItem>
            </MudGrid>
        </MudItem>
    </MudGrid>
    
    
    @if (loadingBlobDetails)
    {
        <MudItem>
            <MudProgressCircular Indeterminate="true" />
        </MudItem>
    }
    else if (blobDetails?.Count > 0)
    {
        <MudGrid>
            <MudItem>
                <MudIconButton Icon="@Icons.Material.Filled.KeyboardReturn" Disabled="@(folderPath.Count == 0)" OnClick='() => { UpdateFolderPath(".."); }'/>
            </MudItem>
            <MudItem Style="margin: auto 0;">
                <CloudStorage.SPA.Components.Views.BreadcrumbsView Breadcrumbs="GetBreadcrumbs()" OnBreadcrumbClicked="(link) => { ParseFolderPath(link); StateHasChanged(); }" />
            </MudItem>
        </MudGrid>
        
        <MudGrid Justify="Justify.FlexStart">
            @if (folderPath.Count == 0 && HasPrivateImages())
            {
                <CloudStorage.SPA.Components.Views.FolderView FolderName="Private" OnClick='() => { folderPath.Clear(); folderPath.Add("__private__");  }' />
            }

            @foreach (string folderName in GetFolders())
            {
                <CloudStorage.SPA.Components.Views.FolderView FolderName="@folderName" OnClick="() => { UpdateFolderPath(folderName); }" />
            }

            @foreach (BlobDetail blobDetail in GetBlobDetailsList())
            {
                <CloudStorage.SPA.Components.Views.BlobDetailView BlobDetail="blobDetail" OnClick="() => { ShowImage(blobDetail); }"/>
            }
        </MudGrid>
    }

</MudContainer>

<MudOverlay @bind-Visible="isOverlayVisible" DarkBackground="true" AutoClose="true" ZIndex="99999">
    @if (overlayImageLoading)
    {
        <MudProgressCircular Indeterminate="true"/>
    }
    else
    {
        <MudImage Src="@overlayImageSrc" Elevation="4" ObjectFit="ObjectFit.Contain" Style="max-height: 95vh; max-width: 100vw;" />
    }
    
</MudOverlay>

@code {
    List<string> folderPath = new List<string>();
    User? user { get; set; } = null;
    List<BlobDetail>? blobDetails { get; set; }

    public bool showPrivate { get; set; } = false;
    bool loadingBlobDetails { get; set; } = true;
    bool isOverlayVisible { get; set; } = false;
    string overlayImageSrc { get; set; } = string.Empty;
    bool overlayImageLoading { get; set; } = false;

    protected override Task OnInitializedAsync()
    {
        string uri = navManager.ToBaseRelativePath(navManager.Uri);
        IDictionary<string, string> queryParamters = Worker.GetQueryParameters(uri);

        if(queryParamters.ContainsKey("route"))
        {
            string currFolder = queryParamters["route"].Trim('/');
            folderPath = currFolder.Split('/').ToList();
            StateHasChanged();
        }

        return base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || user == null)
        {
            try
            {
                user = (await protectedStorage.GetAsync<User>(Consts.Storage.USER)).Value;

                if (user == null)
                {
                    navManager.NavigateTo("/");
                }

                if (blobDetails == null)
                {
                    await GetBlobDetails();
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                snackbar.Add(ex.Message, Severity.Error);
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected async Task GetBlobDetails()
    {
        loadingBlobDetails = true;
        try
        {
            HttpClient client = clientFactory.CreateClient("api");

            HttpRequestMessage requestMessage = new HttpRequestMessage(HttpMethod.Get, "/Blob");
            HttpResponseMessage responseMessage = await client.SendAsync(requestMessage);

            if (responseMessage.IsSuccessStatusCode)
            {
                string content = await responseMessage.Content.ReadAsStringAsync();
                blobDetails = JsonConvert.DeserializeObject<List<BlobDetail>>(content);

                if (blobDetails != null)
                {
                    //await sessionStorage.SetItemAsync<string>("blobDetailsList", content);
                }
            }
        }
        catch (Exception ex)
        {
            snackbar.Add(ex.Message, Severity.Error);
        }

        loadingBlobDetails = false;
    }

    private async void UploadFiles(IBrowserFile file)
    {
        try
        {
            long fileSize = file.Size;
            byte[] data = new byte[(int)file.Size];
            Stream stream = file.OpenReadStream(file.Size);
            await stream.ReadAsync(data, 0, (int)fileSize);
            string imageB64 = Convert.ToBase64String(data);

            FileUpload fileUpload = new FileUpload()
            {
                ContainerName = "pictures",
                FileExtension = file.Name.Remove(0, file.Name.LastIndexOf('.')),
                FileName = Guid.NewGuid().ToString(),
                DataBase64 = imageB64,
                IsPrivate = folderPath.Contains("__private__")
            };

            string fileUploadContent = JsonConvert.SerializeObject(fileUpload);

            HttpClient client = clientFactory.CreateClient("api");
            HttpRequestMessage requestMessage = new HttpRequestMessage(HttpMethod.Post, "/Blob");
            requestMessage.Content = new StringContent(fileUploadContent, System.Text.Encoding.UTF8, "application/json");

            HttpResponseMessage responseMessage = await client.SendAsync(requestMessage);

            if (responseMessage.IsSuccessStatusCode)
            {
                await GetBlobDetails();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private List<string> GetFolders()
    {
        List<string> folderList = new List<string>();
        string route = GetRoute().Trim('/');

        foreach(BlobDetail detail in blobDetails?.Where(x => x.FileName.StartsWith(route)).ToList() ?? [])
        {
            string relativeFileName =  string.IsNullOrEmpty(route) ? detail.FileName : detail.FileName.Replace(route, "").Trim('/');

            int fileNameStart = relativeFileName.LastIndexOf('/');
            string fileName = fileNameStart != -1 ? relativeFileName.Substring(fileNameStart + 1) : relativeFileName;
            string folderPath = fileNameStart != -1 ? relativeFileName.Substring(0, fileNameStart) : "";
            string[] folders = folderPath.Length > 0 ? folderPath.Split('/') : [];

            if (folders.Length >= 1)
            {
                if (!folderList.Contains(folders[0]))
                {
                    folderList.Add(folders[0]);
                }
            }
        }

        return folderList;
    }

    private List<BlobDetail> GetBlobDetailsList() {

        List<BlobDetail> detailsList = new List<BlobDetail>();
        string route = GetRoute().Trim('/');
        if (string.Equals(route, "__private__"))
        {
            return blobDetails?.Where(x => x.Private == true).ToList() ?? [];
        }

        foreach(BlobDetail detail in blobDetails ?? [])
        {
            if (detail.FileName.StartsWith(route) && detail.Private == false)
            {
                string remainingFileName = detail.FileName.Remove(0, route.Length).Trim('/');

                if (!remainingFileName.Contains("/"))
                {
                    detailsList.Add(detail);
                }
            }
        }

        return detailsList;
    }

    private bool HasPrivateImages()
    {
        return blobDetails?.Any(x => x.Private == true) ?? false;
    }

    private async void ShowImage(IBlobDetail pBlobDetail)
    {
        try
        {
            isOverlayVisible = true;
            overlayImageLoading = true;

            HttpClient client = clientFactory.CreateClient("api");
            HttpRequestMessage imageRequest = new HttpRequestMessage(HttpMethod.Get, $"Blob/{pBlobDetail.FileName}");
            HttpResponseMessage imageResponse = await client.SendAsync(imageRequest);

            if (imageResponse.IsSuccessStatusCode)
            {
                byte[] imageData = await imageResponse.Content.ReadAsByteArrayAsync();
                string base64Image = Convert.ToBase64String(imageData);

                overlayImageSrc = $"data:image/jpg;base64, {base64Image}";
                overlayImageLoading = false;
                StateHasChanged();
            }

        }
        catch (Exception ex)
        {
            isOverlayVisible = false;
        }
    }

    private List<Breadcrumb> GetBreadcrumbs()
    {
        List<Breadcrumb> breadcrumbs = new List<Breadcrumb>();

        breadcrumbs.Add(new Breadcrumb() { DisplayName = "", Link = "", Icon = Icons.Material.Filled.Folder });

        StringBuilder fullPath = new StringBuilder();
        foreach(string path in folderPath ?? [])
        {
            if (string.Equals(path, "__private__"))
            {
                breadcrumbs.Add(new Breadcrumb() { DisplayName = "Private", Link = "Gallery?route=__private__", Icon = Icons.Material.Filled.Folder });
            }
            else {
                fullPath.Append($"/{path.Trim('/')}");

                breadcrumbs.Add(new Breadcrumb() { DisplayName = path, Link = fullPath.ToString(), Icon = Icons.Material.Filled.Folder });
            }
        }

        return breadcrumbs;
    }

    private void UpdateFolderPath(string pPath)
    {
        if (string.Equals(pPath.Trim(), "..") && folderPath.Count() > 0)
        {
            folderPath.RemoveAt(folderPath.Count() - 1);
        }
        else
        {
            folderPath.Add(pPath);
        }
        StateHasChanged();
    }

    private string GetRoute()
    {
        StringBuilder route = new StringBuilder();
        foreach (string path in folderPath)
        {
            route.Append($"/{path}");
        }

        return route.ToString();
    }

    private void ParseFolderPath(string pNewRoute)
    {
        if (string.IsNullOrEmpty(pNewRoute))
        {
            folderPath = new List<string>();
        }
        else
        {
            string[] parts = pNewRoute.Trim('/').Split('/');
            folderPath = new List<string>(parts);
        }
    }
}
